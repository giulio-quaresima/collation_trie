#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "collation_trie.h"
#include "utils.h"

typedef struct trie_node {
    struct trie_node **children; // the array of pointers to children
    unsigned char offset;        // the offset of the first child
    unsigned char length;        // the length of the children array
    char *key;                   // the unique key of the node: it is not possible to rebuild the key traversing up the tree,
                                 // because the trie is build using the collation string generated by the strxfrm function
    void *value;                 // the optional value associated to the key
} trie_node;

// Definition of the public struct collation_trie, declared in header file
struct collation_trie {
    struct trie_node *root;      // the root node
    unsigned int node_count;     // the total number of nodes
    unsigned int key_count;      // the total number of keys
};

struct trie_node *collation_trie_new_empty_node() 
{
    struct trie_node *node = xmalloc(sizeof(struct trie_node)); 
    node->key = NULL;
    node->value = NULL;
    node->offset = 0;
    node->length = 0;
    node->children = NULL;
    return node;
}

struct trie_node **collation_trie_alloc_children(unsigned char length)
{
    struct trie_node **children = xmalloc(length * sizeof (void*));
    for (unsigned char index = 0; index < length; index++)
    {
        children[index] = NULL;
    }
    return children;
}

struct collation_trie *collation_trie_new() 
{
    struct collation_trie *trie = xmalloc(sizeof(struct collation_trie)); 
    trie->root = collation_trie_new_empty_node(); 
    trie->node_count = 1;
    trie->key_count = 0;
    return trie;
}

static void* put_internal(char *key, void *value, char *coll_string, size_t depth, size_t length, struct trie_node *node, struct collation_trie *trie);
void* collation_trie_put(struct collation_trie *trie, char *key, void *value)
{
    if (key == NULL || trie == NULL || trie->root == NULL)
    {
        return NULL;
    }
    
    size_t length = strxfrm(NULL, key, 0);
    char *coll_string = (char*) xmalloc((length+1) * sizeof (char));
    strxfrm(coll_string, key, length+1);
    return put_internal(key, value, coll_string, 0, length, trie->root, trie);
}

static void* get_internal(char *coll_string, size_t depth, size_t length, struct trie_node *node);
void* collation_trie_get(struct collation_trie *trie, char *key)
{
    if (key == NULL || trie == NULL || trie->root == NULL)
    {
        return NULL;
    }
    
    size_t length = strxfrm(NULL, key, 0);
    char *coll_string = (char*) xmalloc((length+1) * sizeof (char));
    strxfrm(coll_string, key, length+1);
    return get_internal(coll_string, 0, length, trie->root);
}

unsigned int collation_trie_size(struct collation_trie *trie)
{
    if (trie != NULL)
    {
        return trie->key_count;
    }
    return 0;
}

static void traverse_pre_order_internal(void visitor(char*, void*), struct trie_node *node);
void collation_trie_traverse_pre_order(struct collation_trie *trie, void visitor(char*, void*))
{
    if (trie != NULL)
    {
        traverse_pre_order_internal(visitor, trie->root);
    }
}

static void free_internal(struct trie_node *node, _Bool frees_keys, _Bool frees_values);
void collation_trie_free(struct collation_trie *trie, _Bool frees_keys, _Bool frees_values)
{
    free_internal(trie->root, frees_keys, frees_values);
    xfree((void**) &trie);
}


// Definitions of static internal members /////////////////////////////////////////////////////

static void* put_internal(char *key, void *value, char *coll_string, size_t depth, size_t length, struct trie_node *node, struct collation_trie *trie)
{
    if (depth == length) // Condizione d'uscita dalla ricorsione
    {
        if (node->key == NULL)
        {
            node->key = key;
            trie->key_count++;
        }
        
        void *old_value = value;
        node->value = value;

        return old_value;
    }

    unsigned char coll_char = coll_string[depth];
    
    if (node->children == NULL)
    {
        node->offset = coll_char;
        node->length = 1;
        node->children = collation_trie_alloc_children(node->length);
        // TODO test if alloc didn't succeed
    }
    else if (coll_char < node->offset) // Occorre ampliare l'array a sinistra
    {
        unsigned char shift = (node->offset - coll_char);
        node->offset = coll_char;
        node->length += shift;
        struct trie_node **new_children = realloc(node->children, (node->length * sizeof (void*)));
        // TODO test if alloc didn't succeed
        node->children = new_children;
        for (unsigned char index = (node->length - 1); index >= shift; index--)
        {
            node->children[index] = node->children[index - shift];
        }
        for (unsigned char index = 0; index < shift; index++)
        {
            node->children[index] = NULL;
        }
    }
    else if ((coll_char - node->offset) >= node->length) // Occorre ampliare l'array a destra
    {
        unsigned char shift = (((coll_char - node->offset) - node->length) + 1);
        node->length += shift;
        struct trie_node **new_children = realloc(node->children, (node->length * sizeof (void*)));
        // TODO test if alloc didn't succeed
        node->children = new_children;
        for (unsigned char index = (node->length - 1); index >= (node->length - shift); index--)
        {
            node->children[index] = NULL;
        }
    }
    
    unsigned char index = coll_char - node->offset;

    if (node->children[index] == NULL)
    {
        node->children[index] = collation_trie_new_empty_node(); 
        trie->node_count++;
    }
    
    return put_internal(key, value, coll_string, depth+1, length, node->children[index], trie);
}

static void* get_internal(char *coll_string, size_t depth, size_t length, struct trie_node *node)
{
    if (node != NULL)
    {
        if (depth == length) // Condizione d'uscita dalla ricorsione
        {
            return node->value;
        }
        
        if (node->children != NULL)
        {
            unsigned char coll_char = coll_string[depth];
            if (coll_char >= node->offset && coll_char < (node->offset + node->length))
            {
                return get_internal(coll_string, depth+1, length, node->children[coll_char - node->offset]);
            }
        }
    } 

    return NULL;
}

static void free_internal(struct trie_node *node, _Bool frees_keys, _Bool frees_values)
{
    // I set up a depth-first, post-order recursion in order to avoid frees nodes with yet allocated children.
    if (node)
    {
        if (node->children)
        {
            for (unsigned char index = 0; index < node->length; index++)
            {
                free_internal(node->children[index], frees_keys, frees_values); // first frees the child's data
            }
            xfree((void**) &node->children); // frees the array of children
        }

        if (frees_keys && node->key)
        {
            xfree((void**) &node->key); // if allowed, frees the key
        }
        if (frees_values && node->value)
        {
            xfree((void**) &node->value); // if allowed, frees the value
        }
        
        xfree((void**) &node); // eventually, frees the node itself
    }
}

static void traverse_pre_order_internal(void visitor(char*, void*), struct trie_node *node)
{
    if (node != NULL)
    {
        // Pre-order
        if (node->key != NULL) // Only not empty nodes (i.e. nodes associated with a key) will be visited
        {
            visitor(node->key, node->value);
        }
        for (unsigned char index = 0; index < node->length; index++)
        {
            traverse_pre_order_internal(visitor, node->children[index]);
        }
    }
}
